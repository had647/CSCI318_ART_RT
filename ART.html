<html>

<head>
  <title>ART</title>
  <style>
    /* This is used to have two Canvas Side by Side*/
    #wrapper {
      display: flex;
    }

    #canvasContainer {
      flex: 0 0 35%;
      /* Change the 35% if you want to move the second Canvas to the right */
    }

    #canvasContainer2 {
      flex: 1;
    }
  </style>














  <script>

    let state = {
      testCases: [],
      candidates: [],
      failRegion: {
        coords: { 'x': null, 'y': null },
        edgeSize: null
      },
      canvasSize: null,
      canvasRef: null
    };


    //calculates the smallest distance between a candidate case, and all current test cases
    function calculate_min_distance(candidate) {

      let min_distance = -1;  //smallest distance after measuring distance between candidate and all other test cases
      let di = -1;            //distance between the candidate and all test cases

      for (let i = 0; i < state.testCases.length; i++) {     //iterating through each test case

        di = Math.sqrt(Math.pow((candidate.x - state.testCases[i].x), 2) + Math.pow((candidate.y - state.testCases[i].y), 2));   //equation for measuring distance

        if (i === 0) { min_distance = di; }             //assume the first distance is the smallest
        if (di < min_distance) { min_distance = di; }   //if a smaller distance is found, update the min_distance
      }

      console.log(min_distance);
      return min_distance;
    }



    function getNewCandidates(k) {
      //let k = 1; //should be input argument
      let d = 0;
      genNewCandidates();
      console.log(state.candidates);
      let t;
      let di;
      for (let i = 0; i < state.candidates.length; i++) {
        di = calculate_min_distance(state.candidates[i]);
        console.log(di);
        if (di > d) {
          d = di;
          t = state.candidates[i];
        }
      }
      state.testCases.push(t);

    }

    // Just using to visualise how it works.
    //getNewCandidates(2);
    //console.log(test_cases);



    function genNewCandidates() {
      for (let i = 0; i < 10; i++) {     //randomly generate candidates
        state.candidates[i] = { 'x': Math.random() * state.failRegion.edgeSize, 'y': Math.random() * state.failRegion.edgeSize };
        // candidates.push({ 'x': Math.random() * edge_size, 'y': Math.random() * edge_size });
      }
    }



    function checkCollision(i) {
      //'i' is the test case index to check for collisions with
      if (state.test_cases[i].x >= state.failRegion.coords.x && state.test_cases[i].x <= (state.failRegion.coords.x + state.failRegion.edgeSize)
        && state.test_cases[i].y >= state.failRegion.coords.y && state.test_cases[i].y <= (state.failRegion.coords.y + state.failRegion.edgeSize)) return true;
      return false;
    }


    /*function resetstate() {
      state.candidates = [];
      state.test_cases = [];
    }*/









    function initBlankCanvas() {
      if (state.canvasSize === null) {
        console.error("Need to initialize state.canvasSize before trying to initialize the canvas!");
        return;
      }
      //this is probably slow - needs optimizing
      document.getElementById("canvasContainer").innerHTML = `<canvas id="myCanvas" width="${state.canvasSize}" height="${state.canvasSize}" style="border:1px solid #c3c3c3;"></canvas>`; //sets height and width based on edge_size
      document.getElementById("canvasContainer2").innerHTML = `<canvas id="myCanvas" width="${state.canvasSize}" height="${state.canvasSize}" style="border:1px solid #c3c3c3;"></canvas>`;

    }


    function initState() {
      //resetstate();
      let fail_region_percent = parseFloat(document.getElementById("failPct").value) / 100;  //user will change this
      console.log(`Using failure pct: ${fail_region_percent}`);

      let edge_size = parseInt(document.getElementById("edgeSize").value);  //change this to set the HxW of the canvas
      console.log(`Using edge size: ${edge_size}px`);

      if (isNaN(fail_region_percent) || fail_region_percent > 1 || fail_region_percent <= 0 || isNaN(edge_size) || edge_size <= 0) {
        console.error("INVALID");
        return;
      } else {
        console.log("INPUT VALID");
      }

      let fail_region_edge_size = Math.sqrt(edge_size * edge_size * fail_region_percent);  //width and height of fail region

      let border_limit_max = edge_size - fail_region_edge_size; //determines the maximum x and y coordinate for the fail region to prevent the fail region from being cut off by the border

      let random_x = Math.random() * border_limit_max;  //generates a random number inclusively between 0 and the border_limit_max
      let random_y = Math.random() * border_limit_max;  //" "

      let random_x_test_case = Math.random() * edge_size; //these may need to change
      let random_y_test_case = Math.random() * edge_size;

      //update app state
      state.failRegion.edgeSize = fail_region_edge_size;
      state.failRegion.coords.x = random_x;
      state.failRegion.coords.y = random_y;
      state.canvasSize = edge_size;
      state.test_cases.push({ 'x': random_x_test_case, 'y': random_y_test_case });
      state.canvasRef = document.getElementById("myCanvas");     //setting up canvas stuff


      let ctx = state.canvasRef.getContext("2d");                    //setting up the fail region

      //collision demonstration
      if (checkCollision(0)) {
        console.log("COLLISION");
        document.getElementById("output_result").innerHTML = "HIT!";
        ctx.fillStyle = "red";                            //colour of fail region
        ctx.fillRect(random_x, random_y, fail_region_edge_size, fail_region_edge_size);

      } else { //no collision occurs
        ctx.fillStyle = "green";                            //colour of fail region
        ctx.fillRect(random_x, random_y, fail_region_edge_size, fail_region_edge_size);       //rendering the fail region
        document.getElementById("output_result").innerHTML = "MISSED!";
      }

      ctx.fillStyle = "black";
      ctx.beginPath();
      ctx.arc(random_x_test_case, random_y_test_case, 5, 0, 2 * Math.PI);
      ctx.stroke();
      ctx.fill();
    }

  </script>
</head>


























<body>
  <span>Enter failure area percentage:</span>
  <input type="text" id="failPct"></input>
  <span>%</span>

  <br />

  <span>Enter edge size as an integer:</span>
  <input type="text" id="edgeSize"></input>
  <span>px <i>(For display purposes, we recommend the range 250px to 800px.)</i></span> <br /> <br />

  <button onclick="runTest()">Go!</button> <br /><br />

  <div id="wrapper">
    <div id="canvasContainer"></div>
    <div id="canvasContainer2"></div>
  </div>

  <br />

  <div id="output_result"></div>

</body>

</html>