<!DOCTYPE html>
<html>

<head>
  <!-- Required meta tags -->
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <!-- Bootstrap CSS -->
  <!--<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css">-->
  <title>Algorithm Visualization Tool</title>

  <style>
    body {
      margin: 0px;
      font-family: "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
      font-size: 1rem;
      font-weight: 400;
      line-height: 1.5;
      color: #212529;
      text-align: left;
      background-color: #fff;
      display: block;
    }

    h2 {
      margin-top: 0;
      margin-bottom: .5rem;
      font-weight: 500;
      line-height: 1.2;
      font-size: 2rem;
    }

    button {
      margin: 0;
      font-family: inherit;
      font-size: inherit;
      line-height: inherit;
    }

    *,
    ::after,
    ::before {
      box-sizing: border-box;
    }

    .header {
      background-color: #3399FF;
      padding-right: 15px;
      padding-left: 15px;
      min-width: 310px;
    }

    .headerLabel {
      color: #f8f9fa;
      padding-top: 15px;
      padding-bottom: 13px;
    }

    .content {
      padding: 0px;
      background-color: #f8f9fa;
      display: flex;
    }

    .navRow {
      height: 35px;
      background-color: #292e33;
      color: #f8f9fa;
      font-size: 1.25rem;
      font-weight: 300;
      width: 100%;
    }

    .inputGroup {
      position: relative;
      display: flex;
      flex-wrap: wrap;
      width: 100%;
    }

    .inputGroupText {
      padding: .375rem .75rem;
      font-size: 1rem;
      color: #495057;
      text-align: center;
      white-space: nowrap;
      background-color: #e9ecef;
      border: 1px solid #ced4da;
      border-radius: .25rem;
    }

    .inputGroupName {
      width: 150px;
    }

    .inputGroupUnits {
      width: 40px;
    }

    .formControl {
      display: block;
      width: 110px;
      padding: .375rem .75rem;
      font-size: 1rem;
      color: #495057;
      background-color: #fff;
      border: 1px solid #ced4da;
    }

    .navLabel {
      width: 100%;
      text-align: center;
      margin: 0px;
    }

    .paramBar {
      position: relative;
      margin: 0px;
      padding: 5px;
      color: #f8f9fa;
      background-color: #343a40;
      width: 310px;
      min-width: 310px;
    }

    .canvasWrapper {
      padding: 10px;
    }

    /*buttons*/
    .button {
      cursor: pointer;
      color: #fff;
      text-align: center;
      border: 1px solid;
      padding: .375rem .75rem;
      border-radius: .25rem;
      transition: background-color .15s ease-in-out, border-color .15s ease-in-out;
    }

    .buttonGo {
      width: 40px;
      padding-left: 7px;
      background-color: #007bff;
      border-color: #006fe6;
    }

    .buttonGo:hover {
      background-color: #006fe6;
      border-color: #0063cc;
    }

    .buttonSuccess {
      width: 100%;
      background-color: #2db94d;
      border-color: #28a445;
    }

    .buttonSuccess:hover {
      background-color: #28a445;
      border-color: #23903c;
    }

    .buttonNext {
      width: 100%;
      background-color: #d92638;
      border-color: #c32232;
    }

    .buttonNext:hover {
      background-color: #c32232;
      border-color: #ad1f2d;
    }
  </style>

  <script>

    let state = {
      testCases: [],
      candidates: [],
      failRegion: {
        coords: { 'x': null, 'y': null },
        edgeSize: null,
        area: null
      },
      canvasSize: null,
      canvasRef: null,
      collision: false,
      loopCount: 0
    };

    //calculates the smallest distance between a candidate case, and all current test cases
    function calculate_min_distance(candidate) {

      let min_distance = -1;  //smallest distance after measuring distance between candidate and all other test cases
      let di = -1;            //distance between the candidate and all test cases

      for (let i = 0; i < state.testCases.length; i++) {     //iterating through each test case

        di = Math.sqrt(Math.pow((candidate.x - state.testCases[i].x), 2) + Math.pow((candidate.y - state.testCases[i].y), 2));   //equation for measuring distance

        if (i === 0) { min_distance = di; }             //assume the first distance is the smallest
        if (di < min_distance) { min_distance = di; }   //if a smaller distance is found, update the min_distance
      }
      //console.log(min_distance);
      return min_distance;
    }

    function getNextTestCase() {
      state.loopCount++;
      //let k = 1; //should be input argument
      let d = 0;
      genNewCandidates();
      //console.log(state.candidates);
      let t;
      let di;
      for (let i = 0; i < state.candidates.length; i++) {
        di = calculate_min_distance(state.candidates[i]);
        //console.log(di);
        if (di > d) {
          d = di;
          t = state.candidates[i];
        }
      }
      state.testCases.push(t);
      checkForCollision();
    }

    function genNewCandidates() {
      for (let i = 0; i < 10; i++) {     //randomly generate new set of candidates
        state.candidates[i] = { 'x': Math.random() * state.canvasSize, 'y': Math.random() * state.canvasSize };
      }
    }

    function initBlankCanvas() {
      if (state.canvasSize === null) {
        console.error("Need to initialize state.canvasSize before trying to initialize the canvas!");
        return;
      }

      //this is probably slow - needs optimizing - altered for readability
      //sets height and width based on edge_size
      document.getElementById("artContainer").innerHTML = `
        <h2 class="p-2">ART</h2>
        <canvas id="myCanvas" width="${state.canvasSize}" height="${state.canvasSize}" style="border:1px solid #c3c3c3;"></canvas>
        <h6 class="p-2" id="art_output_result"></h6>`;
      document.getElementById("rtContainer").innerHTML = `
        <h2 class="p-2">RT</h2>
        <canvas id="myCanvas" width="${state.canvasSize}" height="${state.canvasSize}" style="border:1px solid #c3c3c3;"></canvas>
        <h6 class="p-2" id="rt_output_result"></h6>`;
    }

    function initState() {
      //resetstate();
      state.testCases = [];
      state.collision = false;
      state.loopCount = 0;

      let fail_region_percent = parseFloat(document.getElementById("failPct").value) / 100;  //user will change this
      console.log(`Using failure pct: ${fail_region_percent}`);

      let edge_size = parseInt(document.getElementById("edgeSize").value);  //change this to set the HxW of the canvas
      console.log(`Using edge size: ${edge_size}px`);

      if (isNaN(fail_region_percent) || fail_region_percent > 1 || fail_region_percent <= 0 || isNaN(edge_size) || edge_size <= 0) {
        console.error("Enter valid failure percentage: 1%-100% and canvas edge size: 250px-800px!");
        return;
      } else {
        console.log("INPUT VALID");
      }

      let fail_region_edge_size = Math.sqrt(edge_size * edge_size * fail_region_percent);  //width and height of fail region

      let border_limit_max = edge_size - fail_region_edge_size; //determines the maximum x and y coordinate for the fail region to prevent the fail region from being cut off by the border

      let random_x = Math.random() * border_limit_max;  //generates a random number inclusively between 0 and the border_limit_max
      let random_y = Math.random() * border_limit_max;  //" "

      let random_x_test_case = Math.random() * edge_size; //these may need to change
      let random_y_test_case = Math.random() * edge_size;

      //update app state
      state.failRegion.edgeSize = fail_region_edge_size;
      state.failRegion.coords.x = random_x;
      state.failRegion.coords.y = random_y;
      state.failRegion.area = fail_region_percent;
      state.canvasSize = edge_size;
      state.testCases.push({ 'x': random_x_test_case, 'y': random_y_test_case });
      initBlankCanvas();
      state.canvasRef = document.getElementById("myCanvas");     //setting up canvas stuff
      drawErrorRegion("green");
      //document.getElementById("output_result").innerHTML = "MISSED!"; //default??? - removed: set by collision
      checkForCollision();
    }

    function checkForCollision() {
      //collision demonstration
      let i = state.testCases.length - 1; //'i' is the test case index to check for collisions with
      if (state.testCases[i].x >= state.failRegion.coords.x && state.testCases[i].x <= (state.failRegion.coords.x + state.failRegion.edgeSize)
        && state.testCases[i].y >= state.failRegion.coords.y && state.testCases[i].y <= (state.failRegion.coords.y + state.failRegion.edgeSize)) {
        console.log("COLLISION");
        document.getElementById("art_output_result").innerHTML = "HIT!✔️";
        state.collision = true;
        drawErrorRegion("red");
        //stop checking for collisions
      } else { //no collision occurs
        //drawErrorRegion("green");
        document.getElementById("art_output_result").innerHTML = "MISSED!❌";
      }
      drawLastTestCase(); //this gets drawn last over the top of whatever else is there
    }

    function drawErrorRegion(color) {
      let ctx = state.canvasRef.getContext("2d");                    //setting up the fail region
      ctx.fillStyle = color;                            //colour of fail region
      ctx.fillRect(state.failRegion.coords.x, state.failRegion.coords.y, state.failRegion.edgeSize, state.failRegion.edgeSize);//rendering the fail region
    }

    function drawLastTestCase() {
      let ctx = state.canvasRef.getContext("2d");
      //drawing a square is more performant than drawing a circle
      ctx.fillStyle = "black";                            //colour of fail region
      ctx.fillRect(state.testCases[state.testCases.length - 1].x, state.testCases[state.testCases.length - 1].y, 2, 2); //rendering the test case
    }

    function driver() {
      initState();

      if (state.failRegion.area < 0.001) {
        while (state.collision === false) {
          getNextTestCase();
        }
      } else {
        var loop = setInterval(function () {
          if (state.collision === true) {
            clearInterval(loop);
          } else {
            getNextTestCase();
          }

        }, 1);
      }
    }

  </script>
</head>

<body>

  <div class="header">
    <div class="headerLabel">
      <h2>🤖 Algorithm Visualization Tool</h2>
    </div>
  </div>

  <div class="content">
    <div class="paramBar">
      <div class="navRow">
        <p class="navLabel">Test Parameters</p>
      </div>

      <br>
      <div class="inputGroup">
        <span class="inputGroupText inputGroupName">Enter Failure Rate:</span>
        <input type="text" class="formControl" id="failPct">
        <span class="inputGroupText inputGroupUnits">%</span>
      </div>

      <div class="inputGroup">
        <span class="inputGroupText inputGroupName">Enter Display Size:</span>
        <input type="text" class="formControl" id="edgeSize">
        <span class="inputGroupText inputGroupUnits">px</span>
        <span><i>(For display purposes, we recommend the range 300px to
            730px.)</i></span><br /><br /><br /><br /><br /><br />
      </div>

      <button class="button buttonSuccess" onclick="driver()">Begin Test</button>
      <button class="button buttonNext" onclick="getNextTestCase()">Next Test
        Case</button><br /><br /><br />

      <div class="navRow">
        <p class="navLabel">Compare Algorithm Speeds</p>
      </div>

      <br>
      <div class="inputGroup">
        <span class="inputGroupText inputGroupName">Number of tests:</span>
        <input type="text" class="formControl"></input>

        <button class="button buttonGo" onclick="">Go!</button>
      </div>

      <br>
      <div class="navLabel" style='font-size:50px;'>🛠️</div>
    </div>

    <div id="artContainer" class="canvasWrapper"></div>
    <div id="rtContainer" class="canvasWrapper"></div>
  </div>

  <!--<script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>-->
  <!--<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js"
    integrity="sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1"
    crossorigin="anonymous"></script>-->
  <!--<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js"
    integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM"
    crossorigin="anonymous"></script>-->
</body>


</html>